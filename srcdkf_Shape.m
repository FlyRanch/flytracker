function [xh,InternalVariablesDS,Features] = srcdkf_Shape(state, Sstate, pNoise, oNoise, InferenceDS,frames)

% SRCDKF  Square Root Central Difference Kalman Filter (Sigma-Point Kalman Filter variant)
%
%   [xh, Sx, pNoise, oNoise, InternalVariablesDS] = srcdkf(state, Sstate, pNoise, oNoise, obs, U1, U2, InferenceDS,frames)
%
%   This filter assumes the following standard state-space model:
%
%     x(k) = ffun[x(k-1),v(k-1),U1(k-1)]
%     y(k) = hfun[x(k),n(k),U2(k)]
%
%   where x is the system state, v the process noise, n the observation noise, u1 the exogenous input to the state
%   transition function, u2 the exogenous input to the state observation function and y the noisy observation of the
%   system.
%
%   INPUT
%         state                state mean at time k-1          ( xh(k-1) )
%         Sstate               lower triangular Cholesky factor of state covariance at time k-1    ( Sx(k-1) )
%         pNoise               process noise data structure     (must be of type 'gaussian' or 'combo-gaussian')
%         oNoise               observation noise data structure (must be of type 'gaussian' or 'combo-gaussian')
%         obs                  noisy observations starting at time k ( y(k),y(k+1),...,y(k+N-1) )
%         InferenceDS          SPOK inference data structure generated by GENINFDS function.
%         frames               [startframe endframe]
%
%   OUTPUT
%         xh                   estimates of state starting at time k ( E[x(t)|y(1),y(2),...,y(t)] for t=k,k+1,...,k+N-1 )
%         Sx                   Cholesky factor of state covariance at time k  ( Sx(k) )
%         pNoise               process noise data structure     (possibly updated)
%         oNoise               observation noise data structure (possibly updated)
%
%         InternalVariablesDS  (optional) internal variables data structure
%            .xh_                 predicted state mean ( E[x(t)|y(1),y(2),..y(t-1)] for t=k,k+1,...,k+N-1 )
%            .Sx_                 predicted state covariance (Cholesky factor)
%            .yh_                 predicted observation ( E[y(k)|Y(k-1)] )
%            .inov                inovation signal
%            .Pinov               inovation covariance
%            .KG                  Kalman gain
%
%   Required InferenceDS fields:
%         .spkfParams           SPKF parameters = [h] with
%                                    h  :  CDKF scale factor / difference step size
%
%   
%   Copyright  (c) Rudolph van der Merwe (2002)
%   Significantly modified by Ebraheem Fontaine (2007) for use with Fly Tracker 
%
%   This file is part of the ReBEL Toolkit. The ReBEL Toolkit is available free for
%   academic use only (see included license file) and can be obtained by contacting
%   rvdmerwe@ece.ogi.edu.  Businesses wishing to obtain a copy of the software should
%   contact ericwan@ece.ogi.edu for commercial licensing information.
%
%   See LICENSE (which should be part of the main toolkit distribution) for more
%   detail.

%=============================================================================================
global PAR 
%keyboard
Xdim  = InferenceDS.statedim;                                % extract state dimension
Odim  = InferenceDS.obsdim;                                  % extract observation dimension
U1dim = InferenceDS.U1dim;                                   % extract exogenous input 1 dimension
U2dim = InferenceDS.U2dim;                                   % extract exogenous input 2 dimension
Vdim  = InferenceDS.Vdim;                                    % extract process noise dimension
Ndim  = InferenceDS.Ndim;                                    % extract observation noise dimension

%------------------------------------------------------------------------------------------------------------------------

% Otherwise, this is the first time running the tracker for the
% particular sequence, so our initial estimate will be the 'state' and
% 'Sstate' passed into this file

NOV = 1;

% initialize these variables since they don't exist yet
xh   = zeros(Xdim,NOV);
xh_  = zeros(Xdim,NOV);%cell(NOV,ITERMAX);
Px = zeros(Xdim,Xdim,NOV);%cell(NOV,ITERMAX);
Py_ = zeros(Odim);%cell(NOV,ITERMAX);
Yh_ = zeros(Odim,1);%cell(NOV,ITERMAX);

%set the first state and covariance to initial condition.  Then save
%this as time step zero.
xh(:,1) = state;
Px(:,:,1) = Sstate*Sstate';
InternalVariablesDS.Px = Px;

  
% Get index vectors for any of the state or observation vector components that are angular quantities
% which have discontinuities at +- Pi radians ?
sA_IdxVec = InferenceDS.stateAngleCompIdxVec;
oA_IdxVec = InferenceDS.obsAngleCompIdxVec;


% Get and calculate CDKF scaling parameters and sigma point weights
h = InferenceDS.spkfParams(1);
hh = h^2;

W1 = [(hh - Xdim - Vdim)/hh   1/(2*hh);                  % sigma-point weights set 1
      1/(2*h)                sqrt(hh-1)/(2*hh)];

W2      = W1;
W2_tmp  = W1;    % I will change the value of this below after the
                 % new Ndim is determined depending on occlusions
W2(1,1) = (hh - Xdim - Ndim)/hh ;                        % sigma-point weights set 2


%===================================== STATE & JOINT ESTIMATION VERSION =========================================
Zeros_Xdim_X_Vdim = zeros(Xdim,Vdim);
Zeros_Vdim_X_Xdim = zeros(Vdim,Xdim);
Zeros_Xdim_X_Ndim = zeros(Xdim,Ndim);
Zeros_Ndim_X_Xdim = zeros(Ndim,Xdim);

nsp1 = 2*(Xdim+Vdim) + 1;             % number of sigma points (first set)
nsp2 = 2*(Xdim+Ndim) + 1;             % number of sigma points (second set)

Sn = oNoise.cov;
Sv = pNoise.cov;
Sx = Sstate;                         % matrix square root of state covariance

    
if (U1dim==0), UU1 = zeros(0,nsp1); end
if (U2dim==0), UU2 = zeros(0,nsp2); end

% if process noise adaptation for joint estimation
if pNoise.adaptMethod
  switch InferenceDS.inftype
   case 'joint'
    idx = pNoise.idxArr(end,:);     % get indeces of parameter block of combo-gaussian noise source
    ind1 = idx(1);                  % beginning index of parameter section
    ind2 = idx(2);                  % ending index of parameter section
    paramdim = ind2-ind1+1;         % infer parameter vector length
    dv = diag(Sv);                  % grab diagonal
    dv = dv(ind1:ind2);             % extract the part of the diagonal that relates to the 'parameter section'
   case 'state'
    ind1 = 1;
    ind2 = Xdim;
    paramdim = Xdim;
    dv = diag(Sv);
  end
end


%--- Loop over all frames ---
for i=frames(1):PAR.framesample:frames(2)
    
    begtime = cputime;

    if (U1dim), UU1 = cvecrep(U1(:,i),nsp1); end
    if (U2dim), UU2 = cvecrep(U2(:,i),nsp2); end

    %------------------------------------------------------
    % EXTRACT DATA FEATURES FROM VIDEO FRAME
    %------------------------------------------------------
    %Features(i).IMfull = PAR.BG;
    Features = feat_detect(i,[],PAR);
    %%%%%%%%%%%%%%%%
    fprintf(['Feature Extraction\n']);
    %-------------------------------------------------------

    %-- Reset to full observation dimension and the occluded points
    InferenceDS.model.obsdim = InferenceDS.obsdim;
    InferenceDS.model.Occ = cell(1,PAR.numfly);

    %----------------------
    % build sigma-point set
    %----------------------
    Z   = cvecrep([state; pNoise.mu],nsp1);
    Sz  = [Sx Zeros_Xdim_X_Vdim; Zeros_Vdim_X_Xdim Sv];
    hSz = h*Sz;
    hSzM = [hSz -hSz];
    Z(:,2:nsp1) = Z(:,2:nsp1) + hSzM;

    % propagate sigma-points through the motion model
    % This is the prediction step.  xh_ and Sx_ are the predicted state and
    % the Cholesky factor of its covariance.
    X_ = feval(InferenceDS.ffun,InferenceDS,Z(1:Xdim,:),Z(Xdim+1:Xdim+Vdim,:), UU1);  
    xh_ = W1(1,1)*X_(:,1) + W1(1,2)*sum(X_(:,2:nsp1),2);
    A = W1(2,1) * ( X_(:,2:Xdim+Vdim+1) - X_(:,Xdim+Vdim+2:nsp1) ) ;
    B = W1(2,2) * ( X_(:,2:Xdim+Vdim+1) + X_(:,Xdim+Vdim+2:nsp1) - cvecrep(2*X_(:,1),Xdim+Vdim));

    % --Calculate predicted state covariance
    [temp,Sx_] = qr([A B]',0);
    Sx_= Sx_';

    %%%%%%%%%%%%%%%%
    fprintf(['Predicted State\n']);
  

    % MEASUREMENT UPDATE
    % I will perform n iterations of the mesurement update equation
    % linearize HFUN
    ITERMAX = 200; % maximum # of filter iterations on ith time step
    xh_prev = cell(ITERMAX,1);
    KG_prev = cell(ITERMAX,1);
    Syx1_prev = cell(ITERMAX,1);
    Syw1_prev = cell(ITERMAX,1);
    D_prev = cell(ITERMAX,1);
    %Bookkeeping for the iterated SPKF
    newstate = xh_;
    
    Xh_ = newstate;
    for n = 1:ITERMAX
        %Reset to full observation dimension and the occluded points
        InferenceDS.model.obsdim = InferenceDS.obsdim;
        InferenceDS.model.Occ = cell(1,PAR.numfly);

        %store current solution and gain
        if n > 1
            xh_prev{n-1} = newstate;
            KG_prev{n-1} = KG;

            Syw1_prev{n-1} = Syw1;
            Syx1_prev{n-1} = Syx1;
        end
        
        %================================================================
        % DATA ASSOCIATION
        % This determines the corresponding/occluded points
        Features = Closest_PtsNrmlGateShape(Features,newstate,i,PAR);
        %%%%%%%%%%%%%%%%
        fprintf(['Data Association\n']);
        
        %========================================================
        % Now that we know which data image points the 2D projections of
        % our current model estimate correspond to, can perform statistical
        % linearizartion on the observation function.
        %
        % The dimension of the observation vector will be:
        % Odim = 3*size(cell2mat(Features(i).Modelpts),1); 
        % 3 * sum(the number of model pts in each camera)
        
        InferenceDS.model.Hmode = 'pts_cross_projray';
        
        %store the indices to 3D points and projection rays
        InferenceDS.model.IdxTo3DPts = Features(i).IdxTo3DPts;
        InferenceDS.model.DataRays = Features(i).DataRays;
        InferenceDS.model.occluded_idx = Features(i).occluded_idx;
        
        if n == 1
            %save the point correspondence for the initial guess
            Features(i).DataptsIC = Features(i).Datapts;
            
        end

        % =================================
        % Based on these Occluded points, change the relevant
        % parameters since the observation dimension is effectively
        % decreased.  I use the '_tmp' tag to identify these
        % parameters!
        % ================================

        DIMofPts = 3;
        
        % Assume 1 fly for now
        Ndim_tmp = DIMofPts*size(cell2mat(Features(i).Datapts),1);
        % extract observation noise dimension

        % I must change this for the pre-evaluation, and actual
        % evaluation since it sizes the buffer in hfun().
        InferenceDS.model.obsdim = Ndim_tmp;


        Zeros_Xdim_X_Ndim_tmp = zeros(Xdim,Ndim_tmp);
        Zeros_Ndim_tmp_X_Xdim = zeros(Ndim_tmp,Xdim);

        nsp2_tmp   = 2*(Xdim+Ndim_tmp) + 1;          % number of sigma
        % points (second set)

        if (U2dim), UU2 = cvecrep(U2(:,i),nsp2_tmp); end
        if (U2dim==0), UU2 = zeros(0,nsp2_tmp); end

        oNoise.mu_tmp = zeros(Ndim_tmp,1);

        %This assumes that all measurements have additive r.v. with
        %the same covariance.
        oNoise.cov_tmp = chol(5e-3*speye(Ndim_tmp),'lower');

        
        Sn_tmp = oNoise.cov_tmp;         % matrix square root of measurement noise covariance
        mu_n_tmp = oNoise.mu_tmp;      % get measurement noise mean

        W2_tmp(1,1) = (hh - Xdim - Ndim_tmp)/hh ;                        % sigma-point weights set 2


        %==================================================================
        % Now we can actually estimate mean and covariance of
        % reduced (or not) dimension observation function.
        %==================================================================
    
        %----------------------
        % build sigma-point set
        %----------------------
        Z  = sparse(cvecrep([newstate; oNoise.mu_tmp] ,nsp2_tmp));
        Sz = [Sx_ Zeros_Xdim_X_Ndim_tmp; Zeros_Ndim_tmp_X_Xdim Sn_tmp];
        hSz = h*Sz;
        hSzM = [hSz -hSz];
        Z(:,2:nsp2_tmp) = Z(:,2:nsp2_tmp) + hSzM;
        
                
        [Y_,InferenceDS] = feval(InferenceDS.hfun, InferenceDS, Z(1:Xdim,:), Z(Xdim+1:Xdim+Ndim_tmp,:), UU2);
        yh_ = W2_tmp(1,1)*Y_(:,1) + W2_tmp(1,2)*sum(Y_(:,2:nsp2_tmp),2);
        C = W2_tmp(2,1) * ( Y_(:,2:Xdim+Ndim_tmp+1) - Y_(:,Xdim+Ndim_tmp+2:nsp2_tmp) );
        D = W2_tmp(2,2) * ( Y_(:,2:Xdim+Ndim_tmp+1) + Y_(:,Xdim+Ndim_tmp+2:nsp2_tmp) ...
            - cvecrep(2*Y_(:,1),Xdim+Ndim_tmp));

        SyxSyw = sparse([C D]);
        Sy = qr(SyxSyw',0);
        Sy = Sy';
        %Py = Sy*Sy';

        %%%%%%%%%%%%%%%%
        fprintf(['Predicted Observation\n']);

        % ===================================
        % Create observation vector
        % ===================================
        obs = [];
        for k = 1:PAR.numcam
            % Observation vector is the concatenation of the moments of the
            % selected projection rays for each camera view
            
            Moments = Features(i).DataRays{k}(:,4:6);

            obs = [obs ; reshape(Moments',[],1)];
        end

        % ========================
        % Calculate Innovation
        % ========================

        inov = obs - yh_;
        
        %keyboard
        %----------------------------------------------
        % STATE AND COVARIANCE UPDATE
        %----------------------------------------------
        Syx1 = SyxSyw(:,1:Xdim);
        Syw1 = SyxSyw(:,Xdim+1:end);

        Pxy = Sx_*Syx1';
        KG = (Pxy / Sy') / Sy;


        %xh = xh_ + KG*inov;
        xh = Xh_ + KG*(inov -  ((Pxy'/Sx_')/Sx_)*(Xh_ - newstate));
        newstate = xh;

        yh  = feval(InferenceDS.hfun, InferenceDS, xh, oNoise.mu_tmp, UU2);
        
        
        fprintf(['Iteration ' num2str(n) '\n']);
        resnrm(n) = (obs-yh)'*Sy*Sy'*(obs-yh) + (Xh_ - newstate)'*Sx_*Sx_'*(Xh_ - newstate);

        %keyboard
        framebk = 1;
        error_thresh = 1e-4;
        if resnrm(n) <= error_thresh
            fprintf(['Error less than ' num2str(error_thresh) '\n']);
            break
        elseif (n > framebk && all(diff(resnrm(n-framebk:n)) >= 0)) 
            %The error has gotten bigger. Revert to the previous iteration
            %solution
            fprintf(['Error is growing:' num2str(resnrm(n:-1:n-framebk)) '\n']);
            xh = xh_prev{n-framebk};
            KG = KG_prev{n-framebk};
            Syw1 = Syw1_prev{n-framebk};
            Syx1 = Syx1_prev{n-framebk};
            break
        end
    end
    


    %Update the Covariance
    [temp,Sx] = qr([Sx_-KG*Syx1 KG*Syw1]',0);
    Sx=Sx';
    Px = Sx*Sx';
    
    
    state  = xh;
    Sstate = Sx;
  
    %--- Store Variables
    InternalVariablesDS.xh_   = xh_;
    InternalVariablesDS.Sx_   = Sx_;
    InternalVariablesDS.yh_   = yh_;
    InternalVariablesDS.Px    = Px;
    InternalVariablesDS.etime = cputime - begtime;
    InternalVariablesDS.filetag = PAR.stub;
    %InternalVariablesDS.LastIter   = LastIter;

    fprintf(['Finished with Frame ' num2str(i) '\n']);

end   %--- loop over all input vectors

% End of Program
%==========================================================================

