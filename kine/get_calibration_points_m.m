% function [L_1, L_2, L_3, F] = get_calibration_points_m
%
% This is a routine for getting the calibration points under the current
% calibration system (for mike tu's data using doug's calibration cube):
%     - Calibrate by taking three images of the calibration cube
%
%     - points are saved with the following file name structure:
%       calib100001.bmp
%       calib200001.bmp
%       calib300001.bmp
%
%     - L_1, L_2, and L_3 are the ginputed points from cam001, cam002, and
%       cam003 respectively; the rows of the L matrices are the different
%       vertices and sides of the cube

function [L_1, L_2, L_3, F] = get_calibration_points_m

order = {   
        'xmin ymin zmin'; ...
        'xmin ymin zmid'; ...
        'xmin ymin zmax'; ...
        'xmin ymid zmin'; ...
        'xmin ymid zmid'; ...
        'xmin ymid zmax'; ...
        'xmin ymax zmin'; ...
        'xmin ymax zmid'; ...
        'xmin ymax zmax'; ...
        
        'xmid ymin zmin'; ...
        'xmid ymin zmid'; ...
        'xmid ymin zmax'; ...
        'xmid ymid zmin'; ...
        'xmid ymid zmid'; ...
        'xmid ymid zmax'; ...
        'xmid ymax zmin'; ...
        'xmid ymax zmid'; ...
        'xmid ymax zmax'; ...
        
        'xmax ymin zmin'; ...
        'xmax ymin zmid'; ...
        'xmax ymin zmax'; ...
        'xmax ymid zmin'; ...
        'xmax ymid zmid'; ...
        'xmax ymid zmax'; ...
        'xmax ymax zmin'; ...
        'xmax ymax zmid'; ...
        'xmax ymax zmax'; ...
    };

last = inputdlg('How many calibration points are there?', '', 1, {'27'});
last = str2num(last{1});

% Get pixel coordinates of calibration points from all three camera views
[ fileName, pName ] = uigetfile('*.bmp','Please click on the first calibration image file');

cal_fig = figure;

for cam = 1:3
    
    fileName(6) = num2str(cam); % Calibration file name info hard-wired here
    imag = imread(([pName,fileName]),'bmp');
    
    imagesc(imag,[min(min(imag)) max(max(imag))]);
    colormap(gray)
    xlabel(sprintf('Press ANY KEY when ready to select a point, then CLICK to record point location \n WARNING: pressing ANY KEY will also ginput the current point the mouse is over as the selected point'))
    
    for point = 1:last
        title(['CAMERA ',num2str(cam),', Point ', order{point},', #',num2str(point+(last*(cam-1))),' of ',num2str(last*3)])
        zoom on
        pause
        L{cam}(point,:) = ginput(1);
    end
    
end

close(cal_fig)
L_1 = L{1};
L_2 = L{2};
L_3 = L{3};

clear x*

% Get corresponding real world coordinates from user input
prompts = {'MIN x/y/z coordinate' 'MID x/y/z coordinate' 'MAX x/y/z coordinate'};
defans = {'0' '4.5' '9'};
graph_title = 'Real World Calibration point values';

F_inputs = inputdlg(prompts, graph_title, 1, defans);

xmin = str2num(F_inputs{1});
xmid = str2num(F_inputs{2});
xmax = str2num(F_inputs{3});

ymin = xmin; zmin = xmin;
ymid = xmid; zmid = xmid;
ymax = xmax; zmax = xmax;

F = [   xmin ymin zmin; ...
        xmin ymin zmid; ...
        xmin ymin zmax; ...
        xmin ymid zmin; ...
        xmin ymid zmid; ...
        xmin ymid zmax; ...
        xmin ymax zmin; ...
        xmin ymax zmid; ...
        xmin ymax zmax; ...
        
        xmid ymin zmin; ...
        xmid ymin zmid; ...
        xmid ymin zmax; ...
        xmid ymid zmin; ...
        xmid ymid zmid; ...
        xmid ymid zmax; ...
        xmid ymax zmin; ...
        xmid ymax zmid; ...
        xmid ymax zmax; ...
        
        xmax ymin zmin; ...
        xmax ymin zmid; ...
        xmax ymin zmax; ...
        xmax ymid zmin; ...
        xmax ymid zmid; ...
        xmax ymid zmax; ...
        xmax ymax zmin; ...
        xmax ymax zmid; ...
        xmax ymax zmax; ...
    ];
                            
  
  % SAVE
  answer = questdlg('Do you want to save the calibration points?','To save or not to save...');
  
  switch answer
      
      case 'Yes'
          clear f* F_inputs L a* c* g* i* l* p* x* y* z*
          uisave 
          
      case 'No'
          return
          
      case 'Cancel'
          return
          
  end
  

                


        

