function [xh, Sx, pNoise, oNoise, InternalVariablesDS,Features] = srcdkf_const(state, Sstate, pNoise, oNoise, InferenceDS,frames,useIC)

% SRCDKF  CONSTRAINED Square Root Central Difference Kalman Filter (Sigma-Point Kalman Filter variant)
%
%   [xh, Sx, pNoise, oNoise, InternalVariablesDS] = srcdkf_const(state, Sstate, pNoise, oNoise, obs, U1, U2, InferenceDS,frames)
%
%   This filter assumes the following standard state-space model:
%
%     x(k) = ffun[x(k-1),v(k-1),U1(k-1)]
%     y(k) = hfun[x(k),n(k),U2(k)]
%
%   where x is the system state, v the process noise, n the observation noise, u1 the exogenous input to the state
%   transition function, u2 the exogenous input to the state observation function and y the noisy observation of the
%   system.
%
%   INPUT
%         state                state mean at time k-1          ( xh(k-1) )
%         Sstate               lower triangular Cholesky factor of state covariance at time k-1    ( Sx(k-1) )
%         pNoise               process noise data structure     (must be of type 'gaussian' or 'combo-gaussian')
%         oNoise               observation noise data structure (must be of type 'gaussian' or 'combo-gaussian')
%         obs                  noisy observations starting at time k ( y(k),y(k+1),...,y(k+N-1) )
%         InferenceDS          SPOK inference data structure generated by GENINFDS function.
%         frames               [startframe endframe]
%
%   OUTPUT
%         xh                   estimates of state starting at time k ( E[x(t)|y(1),y(2),...,y(t)] for t=k,k+1,...,k+N-1 )
%         Sx                   Cholesky factor of state covariance at time k  ( Sx(k) )
%         pNoise               process noise data structure     (possibly updated)
%         oNoise               observation noise data structure (possibly updated)
%
%         InternalVariablesDS  (optional) internal variables data structure
%            .xh_                 predicted state mean ( E[x(t)|y(1),y(2),..y(t-1)] for t=k,k+1,...,k+N-1 )
%            .Sx_                 predicted state covariance (Cholesky factor)
%            .yh_                 predicted observation ( E[y(k)|Y(k-1)] )
%            .inov                inovation signal
%            .Pinov               inovation covariance
%            .KG                  Kalman gain
%
%   Required InferenceDS fields:
%         .spkfParams           SPKF parameters = [h] with
%                                    h  :  CDKF scale factor / difference step size
%
%   
%   Copyright  (c) Rudolph van der Merwe (2002)
%   Significantly modified by Ebraheem Fontaine (2007) for use with Fly Tracker 
%
%   This file is part of the ReBEL Toolkit. The ReBEL Toolkit is available free for
%   academic use only (see included license file) and can be obtained by contacting
%   rvdmerwe@ece.ogi.edu.  Businesses wishing to obtain a copy of the software should
%   contact ericwan@ece.ogi.edu for commercial licensing information.
%
%   See LICENSE (which should be part of the main toolkit distribution) for more
%   detail.
%
%
%   The constrained estimation part follows the paper:
%   S. Julier & J.L. LaViola, "On Kalman Filtering with nonlinear equality
%   constraints" IEEE Trans Sig. Processing 55(6), 2007
%=============================================================================================
global PAR 
%keyboard
Xdim  = InferenceDS.statedim;                                % extract state dimension
Odim  = InferenceDS.obsdim;                                  % extract observation dimension
U1dim = InferenceDS.U1dim;                                   % extract exogenous input 1 dimension
U2dim = InferenceDS.U2dim;                                   % extract exogenous input 2 dimension
Vdim  = InferenceDS.Vdim;                                    % extract process noise dimension
Ndim  = InferenceDS.Ndim;                                    % extract observation noise dimension

%------------------------------------------------------------------------------------------------------------------------
if nargin < 7
    useIC = false;
end

if (exist([PAR.solutionpath 'fly_' PAR.stub '/fly' num2str(frames(1)-PAR.framesample) ...
        '.mat'],'file') == 2 && useIC == false)
    %If there exists a solution from the previous time step, load it into
    %memory.
    load([PAR.solutionpath 'fly_' PAR.stub '/fly' num2str(frames(1)-PAR.framesample) ...
        '.mat']);
    if frames(1) ~= 1
        Px = InternalVariablesDS.Px;
        Sstate = chol(Px)';
    end

    % If a solution has been previously calculated, set the initial
    % state and covariance to the one previous to the start frame.
    state = xh;


    %   xh(:,1) = state;
    %   Px(:,:,1) = Sstate*Sstate';
else
    % Otherwise, this is the first time running the tracker for the
    % particular sequence, so our initial estimate will be the 'state' and
    % 'Sstate' passed into this file
    
    NOV = 1;
    
    % initialize these variables since they don't exist yet
    xh   = zeros(Xdim,NOV);
    Px = zeros(Xdim,Xdim,NOV);%cell(NOV,ITERMAX);
    Py_ = zeros(Odim);%cell(NOV,ITERMAX);
    Yh_ = zeros(Odim,1);%cell(NOV,ITERMAX);

    %set the first state and covariance to initial condition.  Then save
    %this as time step zero.
    xh(:,1) = state;
    Px(:,:,1) = Sstate*Sstate';
    InternalVariablesDS.Px = Px;
end

  
% Get index vectors for any of the state or observation vector components that are angular quantities
% which have discontinuities at +- Pi radians ?
sA_IdxVec = InferenceDS.stateAngleCompIdxVec;
oA_IdxVec = InferenceDS.obsAngleCompIdxVec;


% Get and calculate CDKF scaling parameters and sigma point weights
h = InferenceDS.spkfParams(1);
hh = h^2;

W1 = [(hh - Xdim - Vdim)/hh   1/(2*hh);                  % sigma-point weights set 1
      1/(2*h)                sqrt(hh-1)/(2*hh)];

W2      = W1;
W2_tmp  = W1;    % I will change the value of this below after the
                 % new Ndim is determined depending on occlusions
W2(1,1) = (hh - Xdim - Ndim)/hh ;                        % sigma-point weights set 2

W3 = W1;
W3(1,1) = (hh - Xdim)/hh ;
%===================================== STATE & JOINT ESTIMATION VERSION =========================================
Zeros_Xdim_X_Vdim = zeros(Xdim,Vdim);
Zeros_Vdim_X_Xdim = zeros(Vdim,Xdim);
Zeros_Xdim_X_Ndim = zeros(Xdim,Ndim);
Zeros_Ndim_X_Xdim = zeros(Ndim,Xdim);

nsp1 = 2*(Xdim+Vdim) + 1;             % number of sigma points (first set)
nsp2 = 2*(Xdim+Ndim) + 1;             % number of sigma points (second set)
nsp3 = 2*(Xdim) + 1;

Sn = oNoise.cov;
Sv = pNoise.cov;
Sx = Sstate;                         % matrix square root of state covariance

    
if (U1dim==0), UU1 = zeros(0,nsp1); end
if (U2dim==0), UU2 = zeros(0,nsp2); end

% if process noise adaptation for joint estimation
if pNoise.adaptMethod
  switch InferenceDS.inftype
   case 'joint'
    idx = pNoise.idxArr(end,:);     % get indeces of parameter block of combo-gaussian noise source
    ind1 = idx(1);                  % beginning index of parameter section
    ind2 = idx(2);                  % ending index of parameter section
    paramdim = ind2-ind1+1;         % infer parameter vector length
    dv = diag(Sv);                  % grab diagonal
    dv = dv(ind1:ind2);             % extract the part of the diagonal that relates to the 'parameter section'
   case 'state'
    ind1 = 1;
    ind2 = Xdim;
    paramdim = Xdim;
    dv = diag(Sv);
  end
end

%
%These are the indices of the state that have a constraint associated with
%them, and the constraint value
cidx = {13:15,16:18};
const = {0.09,0.09};

% --- Loop over all frames ---
for i=frames(1):PAR.framesample:frames(2)
    
    begtime = cputime;

    if (U1dim), UU1 = cvecrep(U1(:,i),nsp1); end
    if (U2dim), UU2 = cvecrep(U2(:,i),nsp2); end

    %------------------------------------------------------
    % EXTRACT DATA FEATURES FROM VIDEO FRAME
    %------------------------------------------------------
    % Get .IMfull & .IMbodyfull
    Features = feat_detect(i,[],PAR);
    fprintf(['Feature Extraction\n']);
    %-------------------------------------------------------
    
    %-- Reset to full observation dimension and the occluded points
    InferenceDS.model.obsdim = InferenceDS.obsdim;
    InferenceDS.model.Occ = cell(1,PAR.numfly);
    
    %keyboard
    % if I have calculated enough previous frames use the prediction,
    % otherwise, just do the naive gaussian noise addition
    if i > PAR.ICframe+PAR.NumPrevSol-1
        InferenceDS.model.Fmode = 'predict';
        %load the previous solutions
        recalcIC_Joint([],i-PAR.NumPrevSol:i-2,PAR,'load');
    else
        InferenceDS.model.Fmode = 'naive';
    end
    
    %Convert to Noorgard notation for linear equation.
    nx = Xdim; nv = Vdim;
    SxxSxv = zeros(nx,2*(nx+nv));
    nxnv2 = nx+nv;
    nxnv2 = nxnv2-nx;
    
    SxxSxv(:,nx+1:nx+nv) = Sv;
    nxnv2 = nxnv2-nv;
    
    SxxSxv = [SxxSxv zeros(nx,nxnv2)];
    %keyboard
    SxxSxv(:,1:nx) = Sx;
    [xbar,InferenceDS]  = feval(InferenceDS.ffun,InferenceDS,state,zeros(nv,1), UU1);  
    xh_ = ((hh-nxnv2)/hh)*xbar;
  
    [temp,Sx_] = qr(SxxSxv',0);
    Sx_ = Sx_';
    %%%%%%%%%%%%%%%%
    fprintf(['Predicted State\n']);
  
    %keyboard
    % MEASUREMENT UPDATE
    % I will perform n iterations of the mesurement update equation
    % linearize HFUN
    ITERMAX = 20; % maximum # of filter iterations on ith time step
    xh_prev = cell(ITERMAX,1);
    KG_prev = cell(ITERMAX,1);
    Syx1_prev = cell(ITERMAX,1);
    Syw1_prev = cell(ITERMAX,1);
    D_prev = cell(ITERMAX,1);
    %Bookkeeping for the iterated SPKF
    newstate = xh_;
    
    Xh_ = newstate;
    
    %reset the error value
    resnrm = [];
    
    %keyboard
    
    for n = 1:ITERMAX
        %Reset to full observation dimension and the occluded points
        InferenceDS.model.obsdim = InferenceDS.obsdim;
        InferenceDS.model.Occ = cell(1,PAR.numfly);

        %store current solution and gain
        if n > 1
            xh_prev{n-1} = newstate;
            KG_prev{n-1} = KG;

            Syw1_prev{n-1} = Syw1;
            Syx1_prev{n-1} = Syx1;
        end
        
        % DATA ASSOCIATION
        % This determines the corresponding/occluded points
        % IN: IMbody & IMbodyfull | OUT: DataptsFull & DataRaysFull & occluded_idx & Edgepts & Modelpts & IdxTo3DPts
        Features = Closest_PtsNrmlGate1(Features,newstate,i,PAR);
        %%%%%%%%%%%%%%%%
        fprintf(['Data Association\n']);
        
        %========================================================
        % Now that we know which data image points the 2D projections of
        % our current model estimate correspond to, can perform statistical
        % linearizartion on the observation function.
        %
        % The dimension of the observation vector will be:
        % Odim = 3*size(cell2mat(Features(i).Modelpts),1); 
        % 3 * sum(the number of model pts in each camera)
        
        InferenceDS.model.Hmode = 'pts_cross_projray';
        
        %store the indices to 3D points and projection rays
        InferenceDS.model.IdxTo3DPts = Features(i).IdxTo3DPts;
        InferenceDS.model.DataRays = Features(i).DataRays;
        InferenceDS.model.occluded_idx = Features(i).occluded_idx;
        
        %store the numerator of the planar scaling value to use in
        %observation function 'hfun' in gssm_flyOcc.m
        InferenceDS.model.eta_Num = Features(i).eta_Num;
        
        if n == 1
            %save the point correspondence for the initial guess
            Features(i).DataptsFullIC = Features(i).DataptsFull;
            Features(i).ModelptsIC = Features(i).Modelpts;
            
        end

        % =================================
        % Based on these Occluded points, change the relevant
        % parameters since the observation dimension is effectively
        % decreased.  I use the '_tmp' tag to identify these
        % parameters!
        % ================================

        DIMofPts = 3;

        % Assume 1 fly for now
        Ndim_tmp = DIMofPts*size(cell2mat(Features(i).Datapts),1);
        % extract observation noise dimension

        % I must change this for the pre-evaluation, and actual
        % evaluation since it sizes the buffer in hfun().
        InferenceDS.model.obsdim = Ndim_tmp;


        Zeros_Xdim_X_Ndim_tmp = zeros(Xdim,Ndim_tmp);
        Zeros_Ndim_tmp_X_Xdim = zeros(Ndim_tmp,Xdim);

        nsp2_tmp   = 2*(Xdim+Ndim_tmp) + 1;          % number of sigma
        % points (second set)

        if (U2dim), UU2 = cvecrep(U2(:,i),nsp2_tmp); end
        if (U2dim==0), UU2 = zeros(0,nsp2_tmp); end

        oNoise.mu_tmp = zeros(Ndim_tmp,1);

        %This assumes that all measurements have additive r.v. with
        %the same covariance.
        %oNoise.cov_tmp = chol(5e-3*speye(Ndim_tmp),'lower');
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Customized observation Noise
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % This is the ID vector that identifies which point belongs to
        % which part of the fly's body
        idtag = cell2mat(Features(i).idtag);
        % triple the IDtags because each one represents a 3D point.
        idtag = repmat(idtag,1,3);
        idtag = reshape(idtag',[],1);
        
        obs_sigma = zeros(Ndim_tmp,1);
        obs_sigma(idtag == 1) = 5e-3;
        obs_sigma(idtag == 2) = 5e-2;
        obs_sigma(idtag == 3) = 5e-2;
        oNoise.cov_tmp = chol(spdiags(obs_sigma,0,Ndim_tmp,Ndim_tmp),'lower');
        
        Sn_tmp = oNoise.cov_tmp;         % matrix square root of measurement noise covariance
        mu_n_tmp = oNoise.mu_tmp;      % get measurement noise mean

        W2_tmp(1,1) = (hh - Xdim - Ndim_tmp)/hh ;                        % sigma-point weights set 2


        %==================================================================
        % Now we can actually estimate mean and covariance of
        % reduced (or not) dimension observation function.
        %==================================================================
    
        %----------------------
        % build sigma-point set
        %----------------------
        Z  = sparse(cvecrep([newstate; oNoise.mu_tmp] ,nsp2_tmp));
        Sz = [Sx_ Zeros_Xdim_X_Ndim_tmp; Zeros_Ndim_tmp_X_Xdim Sn_tmp];
        hSz = h*Sz;
        hSzM = [hSz -hSz];
        Z(:,2:nsp2_tmp) = Z(:,2:nsp2_tmp) + hSzM;
        
%         %Apply Constraints
%         for k = 1:length(cidx)
%             %Calculate norm
%             NRM = sqrt(sum(Z(cidx{k},:).^2,1));
%             %Rescale the values that have norm greater that const
%             if any(NRM > const{k})
%                 Z(cidx{k},NRM > const{k}) = const{k}.*Z(cidx{k},NRM > const{k})...
%                     ./repmat(NRM(NRM > const{k}),length(cidx{k}),1);
%             end
%             keyboard
%         end
        
        [Y_,InferenceDS] = feval(InferenceDS.hfun, InferenceDS, Z(1:Xdim,:), Z(Xdim+1:Xdim+Ndim_tmp,:), UU2);
        yh_ = W2_tmp(1,1)*Y_(:,1) + W2_tmp(1,2)*sum(Y_(:,2:nsp2_tmp),2);
        C = W2_tmp(2,1) * ( Y_(:,2:Xdim+Ndim_tmp+1) - Y_(:,Xdim+Ndim_tmp+2:nsp2_tmp) );
        D = W2_tmp(2,2) * ( Y_(:,2:Xdim+Ndim_tmp+1) + Y_(:,Xdim+Ndim_tmp+2:nsp2_tmp) ...
            - cvecrep(2*Y_(:,1),Xdim+Ndim_tmp));

        SyxSyw = sparse([C D]);
        Sy = qr(SyxSyw',0);
        Sy = Sy';
        %Py = Sy*Sy';

        %%%%%%%%%%%%%%%%
        fprintf(['Predicted Observation\n']);

        % ===================================
        % Create observation vector
        % ===================================
        obs = [];
        for k = 1:PAR.numcam
            % Observation vector is the concatenation of the moments of the
            % selected projection rays for each camera view
            
            Moments = Features(i).DataRays{k}(:,4:6);

            obs = [obs ; reshape(Moments',[],1)];
%             eta_scale = InferenceDS.model.eta_scale{k};
%             obs = [obs ; eta_scale.*reshape(Moments',[],1)];
        end

        % ========================
        % Calculate Innovation
        % ========================

        inov = obs - yh_;
        
        %keyboard
        %----------------------------------------------
        % STATE AND COVARIANCE UPDATE
        %----------------------------------------------
        Syx1 = SyxSyw(:,1:Xdim);
        Syw1 = SyxSyw(:,Xdim+1:end);

        Pxy = Sx_*Syx1';
        KG = (Pxy / Sy') / Sy;


        %xh = xh_ + KG*inov;
        xh = Xh_ + KG*(inov -  ((Pxy'/Sx_')/Sx_)*(Xh_ - newstate));
        newstate = xh;
        
        yh  = feval(InferenceDS.hfun, InferenceDS, xh, oNoise.mu_tmp, UU2);


        fprintf(['Iteration ' num2str(n) '\n']);
        resnrm(n) = (obs-yh)'*Sy*Sy'*(obs-yh) + (Xh_ - newstate)'*Sx_*Sx_'*(Xh_ - newstate);

        %keyboard
        framebk = 2;
        %error_thresh = 5e-3;
        error_thresh = 5e-6; % for 'Body Only' Tracking
        [val,nmin] = min(resnrm);
        
        if resnrm(n) <= error_thresh
            fprintf(['Error less than ' num2str(error_thresh) '\n']);
            break
           %(n > framebk && (all(diff(resnrm(n-framebk:n)) >= 0)) 
        elseif (n > framebk && (nmin+framebk <= n)) 
            %The error has gotten bigger. Revert to the previous iteration
            %solution
            fprintf(['Error is growing:' num2str(resnrm(n-framebk:n)) '\n']);
%             xh = xh_prev{n-framebk};
%             KG = KG_prev{n-framebk};
%             Syw1 = Syw1_prev{n-framebk};
%             Syx1 = Syx1_prev{n-framebk};
            xh = xh_prev{nmin};
            KG = KG_prev{nmin};
            Syw1 = Syw1_prev{nmin};
            Syx1 = Syx1_prev{nmin};
            break
        end
    end

    %% save model projections FTMmod 20120607
    Closest_PtsNrmlGate1_plotsave(Features,newstate,i,PAR);

    
    %Update the Covariance
    [temp,Sx] = qr([Sx_-KG*Syx1 KG*Syw1]',0);
    Sx=Sx';
    
    %keyboard
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %Apply Constraints
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %----------------------
    % build sigma-point set
    %----------------------
    Z   = cvecrep(xh,nsp3);
    Sz  = Sx;
    hSz = h*Sz;
    hSzM = [hSz -hSz];
    Z(:,2:nsp3) = Z(:,2:nsp3) + hSzM;

    % propagate sigma-points through the constraint model
    % This is the prediction step.  xh_ and Sx_ are the predicted state and
    % the Cholesky factor of its covariance.
    X_ = feval(InferenceDS.cfun,InferenceDS,Z(1:Xdim,:));
    xh = W3(1,1)*X_(:,1) + W3(1,2)*sum(X_(:,2:nsp3),2);
    A = W3(2,1) * ( X_(:,2:Xdim+1) - X_(:,Xdim+2:nsp3) ) ;
    B = W3(2,2) * ( X_(:,2:Xdim+1) + X_(:,Xdim+2:nsp3) - cvecrep(2*X_(:,1),Xdim));

    %copy
    xhc = xh;
    
    %Apply Type II constraint
    xh = feval(InferenceDS.cfun,InferenceDS,xh);
    %keyboard
    fprintf(['Apply Constraint\n']);
    % --Calculate state covariance after constraint is applied
    [temp,Sx] = qr([A B]',0);
    Sx= Sx';
    
    %Add uncertainty due to applying constraint
    Pextra = (xh-xhc)*(xh-xhc)';
    Sx = chol(Sx*Sx' + Pextra)';
    
    Px = Sx*Sx';
    
    state  = xh;
    Sstate = Sx;
  
         
    %--- Store Variables
    InternalVariablesDS.xh_   = xh_;
    InternalVariablesDS.Sx_   = Sx_;
    InternalVariablesDS.yh_   = yh_;
    InternalVariablesDS.Px    = Px;
    InternalVariablesDS.etime = cputime - begtime;
    InternalVariablesDS.filetag = PAR.stub;
    InternalVariablesDS.numIter   = n;
    InternalVariablesDS.resnrm   = resnrm;
    InternalVariablesDS.Tnew   = InferenceDS.model.Tnew;

    save([PAR.solutionpath 'fly_' PAR.stub '/fly' num2str(i) '.mat'],'xh','InternalVariablesDS');
    save([PAR.solutionpath 'Features_' PAR.stub '/Features' num2str(i) '.mat'],'Features');


    fprintf(['Finished with Frame ' num2str(i) '\n']);

end   %--- loop over all input vectors

% End of Program
%==========================================================================

